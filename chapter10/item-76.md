# Item 76. 가능한 한 실패 원자적으로 만들라
## 실패 원자성(failure atomicity)이란?
- **호출된 메서드가 예외가 발생하여 실패하더라도 해당 객체가 호출 전 상태를 유지하는 것** 을 말한다.
- 예외가 발생해도 객체는 정상적으로 사용할 수 있으므로 시스템의 안전성에 중요하다.

## 메서드를 실패 원자적으로 만드는 방법
### 1. 불변 객체로 설계하는 것
- 불변 객체는 태생적으로 실패 원자적이다.
- 불변 객체의 상태는 생성 시점에 고정되어 이후로 절대 변하지 않기 때문이다.
- 따라서 메서드가 실패해도 기존 객체가 불안정한 상태로 변할 수가 없다 

___

### 2. 유효성 검사
- 가변 객체의 메서드를 실패 원자적으로 만들 수 있는 가장 흔한 방법이다.
- 작업을 수행하기 앞서 매개변수의 유효성을 검사하는 것이다.
- 이는 객체의 내부 상태를 변경하기 전에 잠재적인 예외 가능성 대부분을 걸러낼 수 있다.
```java
public Object pop() {
    if (size == 0)
        throw new EmptyStackException();
    Object result = elements[--size];
    elements[size] = null; // 다 쓴 참조 해제
    return result;
}
```

___

### 3. 실패할 가능성이 있는 모든 코드를 객체의 상태를 바꾸는 코드보다 앞에 배치한다.
- 로직을 수행하기 이전엔 인수의 유효성을 검사할 수 없을 때 사용할 수 있는 방법이다.
- 예시로 TreeMap 이 있다.
    - TreeMap 에 원소를 추가하기 위해선 원소는 TreeMap 의 기준에 따라 비교할 수 있는 타입이어야 한다.
    - 잘못된 타입의 원소를 추가할 경우 트리를 변경하기 앞서서 해당 원소의 적절한 위치를 찾는 과정에서 ClassCastException 을 던진다.
    - 따라서 트리의 상태가 변경되기 전에 예외가 발생하며 상태가 유지된다.

___

### 4. 객체의 임시 복사본으로 로직 수행한 다음, 원래 객체와 교체하는 방법
- 주로 데이터를 임시 자료구조에 저장해 작업하는 게 더 빠른 경우 적용하면 좋은 방식이다.
- ex. 원소 정렬
    - 정렬을 수행하기 전에 입력 리스트의 원소들을 배열로 옮겨 담는다.
    - 배열을 사용하면 정렬 알고리즘의 반복문에서 더 빠른 접근이 가능하다. 
    - 이는 성능을 높이고자 임시 자료구조를 사용한 것이지만, 혹시나 실패해도 원본 입력 리스트는 변하지 않는 효과를 준다.

___

### 5. 작업 도중 발생하는 실패를 가로채는 복구 코드 작성
- 즉, 예외 발생 시 복구 코드를 작성하여 작업 수행 전 상태로 되돌리는 방법이다.
- rollback 과 같다.
- 주로 (디스크 기반의) 내구성을 보장해야 하는 자료구조에 쓰인다.
- 자주 쓰이는 방법은 아니다.
- 대부분은 복구 코드를 직접 작성하기보다 외부 라이브러리나 프레임워크의 기능을 활용한다.
    - ex. @Transactional 

## 실패 원자성을 달성할 수 없는 경우
- 첫 번째, 두 스레드가 동기화 없이 같은 객체를 동시 수정하려 할 때
    - 객체의 일관성이 깨질 수 있다.
    - ConcurrentModificationException 이 발생한다.
    - 이 예외를 잡아냈다고 해서 객체가 여전히 쓸 수 있는 정상적 상태라고 판단할 수 없다.
- 두 번째, Error
    - 시스템 레벨에서의 에러는 일반적 방법으로 복구할 수 없으며 복구 가능한 예외가 아니다.
    - AssertionError 에 대해선 실패 원자적으로 만드려는 시도조차 할 필요가 없다.
    - 실패 원자성도 정상적인 상황 범주의 예외에서나 의미가 있다. 
- 또한, 실패 원자성을 달성하기 위한 비용이나 복잡도가 아주 큰 연산도 존재한다. 


> 메서드 명세에 기술한 예외라면 예외가 발생하더라도, 객체의 상태는 호출 전후가 똑같이 유지돼야 한다는 것이 기본 규칙이다. 이 실패 원자성 규칙을 지키지 못한다면 실패 시의 객체 상태를 API 설명에 명시해야 한다. 
