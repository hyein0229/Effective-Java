# Item 04. 인스턴스화를 막으려거든 private 생성자를 사용하라
정적 메소드와 정적 필드만을 담은 클래스를 만들고 싶을 수 있다.

⇒ 객체 지향적으로 사고하지 않는 이들이 남용하는 방식이다??

객체 지향적이진 않지만 이러한 정적 멤버만 담아놓은 클래스가 쓰임새가 있다고 한다. java.lang.Math 와 java.util.Arrays처럼 기본 타입 값이나 배열 관련 메소드들을 모아놓거나 특정 인터페이스를 구현하는 객체를 생성해주는 정적 팩토리 메소드를 모아놓은  java.util.Collections 같은 유틸리티 클래스가 예시로 있다.

정적 멤버만을 담은 유틸리티 클래스는 인스턴스화를 위해 설계된 것이 아니므로 인스턴스화를 막는 것이 당연하다. 하지만 생성자를 명시하지 않으면 컴파일러가 자동으로 public 기본 생성자를 만든다. 

**추상 클래스로 만드는 것으로는 인스턴스화를 막을 수 없다.** 클래스를 상속 받아 하위 클래스를 만들어 인스턴스화하면 생성이 가능하기 때문이다. 따라서 ***private 생성자를 추가***하여 클래스의 인스턴스화를 매우 간단하게 막을 수 있다.

```java
// 인스턴스를 만들 수 없는 유틸리티 클래스
public class UtilityClass {
	// 기본 생성자로 인스턴스화되는 것을 private 제어자를 통해 막는다. (인스턴스화 방지용)
	private UtilityClass() {
		throw new AssertionError();
	}
	... 
} 
```

- private 이므로 클래스 바깥에서 접근하여 생성하는 것이 불가능하다.
- private 이므로 상속을 불가능하게 하는 효과도 존재한다.
    - 모든 하위 클래스 생성자는 명시적이든 묵시적이든 상위 클래스의 생성자를 호출하기 때문에.
    - 하위 클래스가 상위 클래스의 생성자에 접근할 수 없게 된다.
- 꼭 AssertionError 를 throw 가 필수는 아니나 클래스 안에서 실수로라도 생성자 호출하지 않도록 한다.


**`AssertionError`** 가 무엇인가?

자바 언어에서 발생하는 오류로 자바 프로그램이 예상하는 결과가 나타나지 않을 경우 발생한다. 런타임 오류로 인식되어 코드에서 의도한 바와 다른 결과가 발생하는 문제를 식별할 때 도움된다.
